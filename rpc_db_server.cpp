/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include<iostream>
#include <unordered_map>
#include <vector>
#include <tuple>
#include <unordered_map>
#include <numeric>
#include <bits/stdc++.h>
using namespace std;
#include "rpc_db.hpp"



unordered_map<int, vector<float>> database_old;


// KEY_SESSION, <DATA_ID, DATA_VECTOR>
unordered_map<unsigned long, unordered_map<int, vector<float>>> database;

unsigned long current_session_key = 1;


static unordered_map<unsigned long, string> loggedMap;



bool check_if_logged(LoginCredentials* login_credentials) {
	string username_str(login_credentials->username);
	if (loggedMap.find(login_credentials->session_key) != loggedMap.end() && loggedMap[login_credentials->session_key] == username_str)
		return true;
	
	return false;
}

LoginCredentials *
login_1_svc(char **argp, struct svc_req *rqstp)
{
	static LoginCredentials  result;
	

	// Initialize result struct
	result.username = new char[30];
	strcpy(result.username, *argp);
	result.session_key = current_session_key;

	// session_key = 0 -> ERROR
	cout << "Connecting: " << *argp << endl;
	if (check_if_logged(&result)) {
		cout << "Already logged" << endl;
		result.session_key = 0;
		return &result;
	} 

	// Keep user as logged (using session_key)
	string username(result.username);
	loggedMap[result.session_key] = result.username;

	// Get next available session_key
	current_session_key++;


	return &result;
}

bool_t *
logout_1_svc(LoginCredentials *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		return (bool_t*) false;
	}

	string username_str(argp->username);

	auto get_value = loggedMap.find(argp->session_key);

	if (get_value != loggedMap.end() && loggedMap[argp->session_key] == username_str) {
		loggedMap.erase(argp->session_key);
		result = true;
	} else {
		result = false;
	}

	cout << username_str << " logged out" << endl;
	

	return &result;
}

bool_t *
load_1_svc(LoadParam *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		result = false;
	} else {
		for (int i = 0; i < argp->num; i++) {
			
			vector<float> values (argp->clients_data[i].values, argp->clients_data[i].values + argp->clients_data[i].noValues);
			database[argp->session_key][argp->clients_data[i].dataId] = values;

		}
		cout << "Data was loaded by: " << loggedMap[argp->session_key] << endl;
		result = true;
	}

	return &result;
}

bool_t *
store_1_svc(u_long *argp, struct svc_req *rqstp)
{
	static bool_t result;

	// if (loggedMap.find(*argp) == loggedMap.end()) {
	// 	result = false;
	// } else {
	// 	result = true;
	// }


	return &result;
}


void print_database(unsigned long session_key) {
	cout << endl;
	for (auto & entry : database[session_key]) {
		cout << entry.first << " " << entry.second.size() << " ";
		for (auto & value : entry.second) {
			cout << value << " ";
		}
		cout<< endl;
	}
	cout<< endl;
}


void insert_to_database(SensorData *argp, unsigned long session_key) {
	vector<float> values(argp->values, argp->values + argp->noValues);
	
	database[session_key][argp->dataId] = values;
}

bool_t *
add_1_svc(SensorDataParam *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	result = true;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		result = false;
	} else {
		

		auto get_value_new = database[argp->session_key].find(argp->sensor_data.dataId);

		if (get_value_new != database[argp->session_key].end()) {
			cout << "dataID not found" << endl;
			result = false;
		} else {
			insert_to_database(&(argp->sensor_data), argp->session_key);
			print_database(argp->session_key);
			result = true;
		}

	}
	return &result;
}



bool_t *
del_1_svc(IntegerParam *argp, struct svc_req *rqstp)
{	

	static bool_t  result;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		result = false;
	} else {

		auto get_value_new = database[argp->session_key].find(argp->value);

		if (get_value_new == database[argp->session_key].end()) {
			cout << "dataID not found" << endl;
			result = false;
		} else {
			database[argp->session_key].erase(argp->value);
			print_database(argp->session_key);
			result = true;
		}

	}

	

	return &result;

}

bool_t *
update_1_svc(SensorDataParam *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	/*
	 * insert server code here
	 */

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		result = false;
	} else {
		//cout << argp->session_key << " " << argp->sensor_data. << endl;
		auto get_value_new = database[argp->session_key].find(argp->sensor_data.dataId);

		if (get_value_new == database[argp->session_key].end()) {
			cout << "dataID not found" << endl;
			result = false;
		} else {
			database[argp->session_key].erase(get_value_new);
			insert_to_database(&argp->sensor_data, argp->session_key);
			print_database(argp->session_key);
			result = true;
		}
	}

	return &result;
}

SensorData getSensorData(unsigned long session_key, int id) {
	SensorData result1;

	result1.dataId = id;
	result1.noValues = database[session_key][id].size();

	
	copy(database[session_key][id].begin(), database[session_key][id].end(), result1.values);
	

	return result1;

}

SensorData *
read_1_svc(IntegerParam *argp, struct svc_req *rqstp)
{
	static SensorData  result;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		//result = (SensorData)NULL;
	} else {
		auto get_value_new = database[argp->session_key].find(argp->value);

		if (get_value_new == database[argp->session_key].end()) {
			cout << "dataID not found" << endl;
		
		} else {
			result = getSensorData(argp->session_key, argp->value);
		}
	}

	return &result;
}

StoreResult *
read_all_1_svc(u_long *argp, struct svc_req *rqstp)
{
	static StoreResult result;

	//cout << *argp << endl;
	if (loggedMap.find(*argp) == loggedMap.end()) {
		return (StoreResult*)NULL;
	} else {
		int count = 0;
		for (auto & entry : database[*argp]) {
		
			result.clients_data[count].dataId = entry.first;
			result.clients_data[count].noValues = entry.second.size();
			copy(entry.second.begin(), entry.second.end(), result.clients_data[count].values);
			//cout << result.clients_data[count].dataId << endl;
			count++;
		}
		result.num = count;
	
	}
 	return &result;
}

float getMin(vector<float> data) {
	return *min_element(data.begin(), data.end());
} 

float getMax(vector<float> data) {
	return *max_element(data.begin(), data.end());
} 

float getMean(vector<float> data) {
	return accumulate( data.begin(), data.end(), 0.0 ) / (float)data.size();
} 

float getMedian(vector<float> data) {
	int size = data.size();

	if (size == 0) {
		return 0.f;
	}

	sort(data.begin(), data.end());

	if (size % 2 != 0) {
		return data.at(size / 2);
	} else {
		return (data.at(size / 2) + data.at(size / 2 - 1)) / 2;
	}
} 

Stats *
get_stat_1_svc(IntegerParam *argp, struct svc_req *rqstp)
{
	static Stats  result;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		return (Stats*)NULL;
	} else {
		auto get_value_new = database[argp->session_key].find(argp->value);

		if (get_value_new == database[argp->session_key].end()) {
			cout << "dataID not found" << endl;
		
		} else {
			result.min = getMin(database[argp->session_key][argp->value]);
			result.max = getMax(database[argp->session_key][argp->value]);
			result.mean = getMean(database[argp->session_key][argp->value]);
			result.median = getMedian(database[argp->session_key][argp->value]);
		}
	}

	

	return &result;
}

AllStatsResp *
get_stat_all_1_svc(u_long *argp, struct svc_req *rqstp)
{
	static AllStatsResp  result;

	if (loggedMap.find(*argp) == loggedMap.end()) {
		return (AllStatsResp*)NULL;
	} else {
		int counter = 0;
		for (auto & entry : database[*argp]) {
			result.stats[counter].id = entry.first;
			result.stats[counter].min = getMin(entry.second);
			result.stats[counter].max = getMax(entry.second);
			result.stats[counter].mean = getMean(entry.second);
			result.stats[counter++].median = getMedian(entry.second);
		} 
		result.count = counter;
	}

	return &result;
}
