/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include<iostream>
#include <unordered_map>
#include <vector>
#include <tuple>
#include <unordered_map>
using namespace std;
#include "rpc_db.hpp"

vector<SensorData*> memDB;

unordered_map<int, vector<float>> database_old;


// KEY_SESSION, <DATA_ID, DATA_VECTOR>
unordered_map<unsigned long, unordered_map<int, vector<float>>> database;

unsigned long current_session_key = 1;


static unordered_map<string, unsigned long> loggedMap;


bool check_if_logged(char* username) {
	string username_str(username);

	if (loggedMap.find(username_str) == loggedMap.end())
		return false;
	
	return true;
}

LoginCredentials *
login_1_svc(char **argp, struct svc_req *rqstp)
{
	static LoginCredentials  result;
	result.username = (char*)malloc(sizeof(30));
	result.session_key = 0;


	// session_key = 0 -> ERROR
	cout << "Connecting: " << *argp << endl;
	if (check_if_logged(*argp)) {
		cout << "Already logged" << endl;
		return &result;
	} 


	result.username = new char[30];
	strcpy(result.username, *argp);
	result.session_key = current_session_key++;

	// Keep user as logged (using username)
	string username(result.username);
	loggedMap[username] = result.session_key;


	cout << username << " : " << loggedMap[username] << endl;

	


	return &result;
}

bool_t *
logout_1_svc(char **argp, struct svc_req *rqstp)
{
	static bool_t  result;
	result = true;

	/*
	 * insert server code here
	 */
	std::string username(*argp);

	loggedMap.erase(username);


	return &result;
}

bool_t *
load_1_svc(void *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	result = true;

	/*
	 * insert server code here
	 */
	cout<< "load funcc" << endl;

	return &result;
}

bool_t *
store_1_svc(void *argp, struct svc_req *rqstp)
{
	static bool_t result;
	result = true;

	/*
	 * insert server code here
	 */
	cout<< "store funcc" << endl;

	return &result;
}

void print_database_old() {
	for (auto & entry : database_old) {
		cout << entry.first << " " << entry.second.size() << " ";
		for (auto & value : entry.second) {
			cout << value << " ";
		}
		cout<< endl;
	}
	cout<< endl << endl;
}

void insert_to_database_old(SensorData *argp) {
	vector<float> values(argp->values, argp->values + argp->noValues);
	database_old[argp->dataId] = values;
}

bool_t *
add_1_svc(SensorData *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	result = true;

	// daca exista deja data cu id-ul ala, trebuie intors false
	// vector<float> values(argp->values, argp->values + argp->noValues);
	// database_old[argp->dataId] = values;

	auto get_value = database_old.find(argp->dataId);

	if (get_value != database_old.end()) {
		cout << "dataID not found" << endl;
		result = false;
	} else {
		insert_to_database_old(argp);

		print_database_old();
	}

	
	
	

	return &result;
}



bool_t *
del_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	result = true;
	/*
	 * insert server code here
	 */

	auto get_value = database_old.find(*argp);

	if (get_value == database_old.end()) {
		cout << "dataID not found" << endl;
		result = false;
	} else {
		database_old.erase((*argp));
		print_database_old();
	}

	return &result;
}

bool_t *
update_1_svc(SensorData *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	result = true;
	/*
	 * insert server code here
	 */


	auto get_value = database_old.find(argp->dataId);

	if (get_value == database_old.end()) {
		cout << "dataID not found" << endl;
		result = false;
	} else {
		database_old.erase(get_value);
		insert_to_database_old(argp);
		print_database_old();
	}



	return &result;
}

bool_t *
read_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	/*
	 * insert server code here
	 */

	return &result;
}

bool_t *
get_stat_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	/*
	 * insert server code here
	 */

	return &result;
}

bool_t *
get_stat_all_1_svc(void *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	/*
	 * insert server code here
	 */

	return &result;
}
