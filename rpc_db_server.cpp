/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include<iostream>
#include <unordered_map>
#include <vector>
#include <tuple>
#include <unordered_map>
using namespace std;
#include "rpc_db.hpp"

vector<SensorData*> memDB;

unordered_map<int, vector<float>> database_old;


// KEY_SESSION, <DATA_ID, DATA_VECTOR>
unordered_map<unsigned long, unordered_map<int, vector<float>>> database;

unsigned long current_session_key = 1;


static unordered_map<unsigned long, string> loggedMap;


// bool check_if_logged(char* username) {
// 	string username_str(username);

// 	if (loggedMap.find(username_str) == loggedMap.end())
// 		return false;
	
// 	return true;
// }

bool check_if_logged(LoginCredentials* login_credentials) {
	string username_str(login_credentials->username);
	if (loggedMap.find(login_credentials->session_key) != loggedMap.end() && loggedMap[login_credentials->session_key] == username_str)
		return true;
	
	return false;
}

LoginCredentials *
login_1_svc(char **argp, struct svc_req *rqstp)
{
	static LoginCredentials  result;
	

	// Initialize result struct
	result.username = new char[30];
	strcpy(result.username, *argp);
	result.session_key = current_session_key;

	// session_key = 0 -> ERROR
	cout << "Connecting: " << *argp << endl;
	if (check_if_logged(&result)) {
		cout << "Already logged" << endl;
		result.session_key = 0;
		return &result;
	} 

	// Keep user as logged (using session_key)
	string username(result.username);
	loggedMap[result.session_key] = result.username;

	// Get next available session_key
	current_session_key++;

	cout << loggedMap[result.session_key] << " : " << loggedMap[result.session_key] << endl;

	return &result;
}

bool_t *
logout_1_svc(LoginCredentials *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		return (bool_t*) false;
	}

	string username_str(argp->username);

	auto get_value = loggedMap.find(argp->session_key);

	if (get_value != loggedMap.end() && loggedMap[argp->session_key] == username_str) {
		loggedMap.erase(argp->session_key);
		result = true;
	} else {
		result = false;
	}
	

	return &result;
}

bool_t *
load_1_svc(u_long *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	result = true;

	if (loggedMap.find(*argp) == loggedMap.end()) {
		result = false;
	} else {
		result = true;
	}

	return &result;
}

bool_t *
store_1_svc(u_long *argp, struct svc_req *rqstp)
{
	static bool_t result;

	if (loggedMap.find(*argp) == loggedMap.end()) {
		result = false;
	} else {
		result = true;
	}


	return &result;
}

void print_database_old() {
	for (auto & entry : database_old) {
		cout << entry.first << " " << entry.second.size() << " ";
		for (auto & value : entry.second) {
			cout << value << " ";
		}
		cout<< endl;
	}
	cout<< endl << endl;
}

void print_database(unsigned long session_key) {
	for (auto & entry : database[session_key]) {
		cout << entry.first << " " << entry.second.size() << " ";
		for (auto & value : entry.second) {
			cout << value << " ";
		}
		cout<< endl;
	}
	cout<< endl << endl;
}

void insert_to_database_old(SensorData *argp) {
	vector<float> values(argp->values, argp->values + argp->noValues);
	
	database_old[argp->dataId] = values;
}

void insert_to_database(SensorData *argp, unsigned long session_key) {
	vector<float> values(argp->values, argp->values + argp->noValues);
	
	database[session_key][argp->dataId] = values;
}

bool_t *
add_1_svc(SensorDataParam *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	result = true;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		result = false;
	} else {
		

		auto get_value_new = database[argp->session_key].find(argp->sensor_data.dataId);

		if (get_value_new != database[argp->session_key].end()) {
			cout << "dataID not found" << endl;
			result = false;
		} else {
			insert_to_database(&(argp->sensor_data), argp->session_key);
			print_database(argp->session_key);
			result = true;
		}

		// auto get_value = database_old.find(argp->sensor_data.dataId);

		// if (get_value != database_old.end()) {
		// 	cout << "dataID not found" << endl;
		// 	result = false;
		// } else {
		// 	insert_to_database_old(&(argp->sensor_data));
		// 	print_database_old();
		// 	result = true;
		// }
	}
	return &result;
}



bool_t *
del_1_svc(IntegerParam *argp, struct svc_req *rqstp)
{	

	static bool_t  result;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		result = false;
	} else {
		// auto get_value = database_old.find(argp->value);

		// if (get_value == database_old.end()) {
		// 	cout << "dataID not found" << endl;
		// 	result = false;
		// } else {
		// 	database_old.erase(argp->value);
		// 	print_database_old();
		// 	cout << "aici" << endl;
		// 	result = true;
		// }

		auto get_value_new = database[argp->session_key].find(argp->value);

		if (get_value_new == database[argp->session_key].end()) {
			cout << "dataID not found" << endl;
			result = false;
		} else {
			database[argp->session_key].erase(argp->value);
			print_database(argp->session_key);
			cout << "aici" << endl;
			result = true;
		}

	}

	

	return &result;

}

bool_t *
update_1_svc(SensorDataParam *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	/*
	 * insert server code here
	 */

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		result = false;
	} else {
		// auto get_value = database_old.find(argp->sensor_data.dataId);

		// if (get_value == database_old.end()) {
		// 	cout << "dataID not found" << endl;
		// 	result = false;
		// } else {
		// 	database_old.erase(get_value);
		// 	insert_to_database_old(&argp->sensor_data);
		// 	print_database_old();
		// 	result = true;
		// }

		auto get_value_new = database[argp->session_key].find(argp->sensor_data.dataId);

		if (get_value_new == database[argp->session_key].end()) {
			cout << "dataID not found" << endl;
			result = false;
		} else {
			database[argp->session_key].erase(get_value_new);
			insert_to_database(&argp->sensor_data, argp->session_key);
			print_database(argp->session_key);
			result = true;
		}
	}

	return &result;
}

bool_t *
read_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	/*
	 * insert server code here
	 */

	return &result;
}

bool_t *
get_stat_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	/*
	 * insert server code here
	 */

	return &result;
}

bool_t *
get_stat_all_1_svc(void *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	/*
	 * insert server code here
	 */

	return &result;
}
