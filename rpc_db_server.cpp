/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include<iostream>
#include <unordered_map>
#include <vector>
#include <tuple>
#include <unordered_map>
using namespace std;
#include "rpc_db.hpp"



unordered_map<int, vector<float>> database_old;


// KEY_SESSION, <DATA_ID, DATA_VECTOR>
unordered_map<unsigned long, unordered_map<int, vector<float>>> database;

unsigned long current_session_key = 1;


static unordered_map<unsigned long, string> loggedMap;


// bool check_if_logged(char* username) {
// 	string username_str(username);

// 	if (loggedMap.find(username_str) == loggedMap.end())
// 		return false;
	
// 	return true;
// }

bool check_if_logged(LoginCredentials* login_credentials) {
	string username_str(login_credentials->username);
	if (loggedMap.find(login_credentials->session_key) != loggedMap.end() && loggedMap[login_credentials->session_key] == username_str)
		return true;
	
	return false;
}

LoginCredentials *
login_1_svc(char **argp, struct svc_req *rqstp)
{
	static LoginCredentials  result;
	

	// Initialize result struct
	result.username = new char[30];
	strcpy(result.username, *argp);
	result.session_key = current_session_key;

	// session_key = 0 -> ERROR
	cout << "Connecting: " << *argp << endl;
	if (check_if_logged(&result)) {
		cout << "Already logged" << endl;
		result.session_key = 0;
		return &result;
	} 

	// Keep user as logged (using session_key)
	string username(result.username);
	loggedMap[result.session_key] = result.username;

	// Get next available session_key
	current_session_key++;

	cout << loggedMap[result.session_key] << " : " << loggedMap[result.session_key] << endl;

	return &result;
}

bool_t *
logout_1_svc(LoginCredentials *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		return (bool_t*) false;
	}

	string username_str(argp->username);

	auto get_value = loggedMap.find(argp->session_key);

	if (get_value != loggedMap.end() && loggedMap[argp->session_key] == username_str) {
		loggedMap.erase(argp->session_key);
		result = true;
	} else {
		result = false;
	}
	

	return &result;
}

bool_t *
load_1_svc(LoadParam *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		result = false;
	} else {
		for (int i = 0; i < argp->num; i++) {
			
			vector<float> values (argp->clients_data[i].values, argp->clients_data[i].values + argp->clients_data[i].noValues);
			database[argp->session_key][argp->clients_data[i].dataId] = values;

		// cout << argp->clients_data[i].dataId << " " << argp->clients_data[i].noValues << " ";

		// for (int j = 0; j < argp->clients_data[i].noValues; j++) {
		// 	cout << argp->clients_data[i].values[j] << " ";
		// }
		// cout << endl;
	}
		result = true;
	}

	return &result;
}

bool_t *
store_1_svc(u_long *argp, struct svc_req *rqstp)
{
	static bool_t result;

	// if (loggedMap.find(*argp) == loggedMap.end()) {
	// 	result = false;
	// } else {
	// 	result = true;
	// }


	return &result;
}


void print_database(unsigned long session_key) {
	for (auto & entry : database[session_key]) {
		cout << entry.first << " " << entry.second.size() << " ";
		for (auto & value : entry.second) {
			cout << value << " ";
		}
		cout<< endl;
	}
	cout<< endl << endl;
}


void insert_to_database(SensorData *argp, unsigned long session_key) {
	vector<float> values(argp->values, argp->values + argp->noValues);
	
	database[session_key][argp->dataId] = values;
}

bool_t *
add_1_svc(SensorDataParam *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	result = true;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		result = false;
	} else {
		

		auto get_value_new = database[argp->session_key].find(argp->sensor_data.dataId);

		if (get_value_new != database[argp->session_key].end()) {
			cout << "dataID not found" << endl;
			result = false;
		} else {
			insert_to_database(&(argp->sensor_data), argp->session_key);
			print_database(argp->session_key);
			result = true;
		}

	}
	return &result;
}



bool_t *
del_1_svc(IntegerParam *argp, struct svc_req *rqstp)
{	

	static bool_t  result;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		result = false;
	} else {

		auto get_value_new = database[argp->session_key].find(argp->value);

		if (get_value_new == database[argp->session_key].end()) {
			cout << "dataID not found" << endl;
			result = false;
		} else {
			database[argp->session_key].erase(argp->value);
			print_database(argp->session_key);
			cout << "aici" << endl;
			result = true;
		}

	}

	

	return &result;

}

bool_t *
update_1_svc(SensorDataParam *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	/*
	 * insert server code here
	 */

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		result = false;
	} else {
		//cout << argp->session_key << " " << argp->sensor_data. << endl;
		auto get_value_new = database[argp->session_key].find(argp->sensor_data.dataId);

		if (get_value_new == database[argp->session_key].end()) {
			cout << "dataID not found" << endl;
			result = false;
		} else {
			database[argp->session_key].erase(get_value_new);
			insert_to_database(&argp->sensor_data, argp->session_key);
			print_database(argp->session_key);
			result = true;
		}
	}

	return &result;
}

SensorData getSensorData(unsigned long session_key, int id) {
	SensorData result1;

	result1.dataId = id;
	result1.noValues = 0;

	for (auto & element : database[session_key]) {
		copy(element.second.begin(), element.second.end(), result1.values);
	}

	cout << result1.values[0];

	return result1;

}

SensorData *
read_1_svc(IntegerParam *argp, struct svc_req *rqstp)
{
	static SensorData  result;

	if (loggedMap.find(argp->session_key) == loggedMap.end()) {
		//result = (SensorData)NULL;
	} else {
		auto get_value_new = database[argp->session_key].find(argp->value);

		if (get_value_new == database[argp->session_key].end()) {
			cout << "dataID not found" << endl;
		
		} else {
			result = getSensorData(argp->session_key, argp->value);
		}
	}

	return &result;
}

StoreResult *
read_all_1_svc(u_long *argp, struct svc_req *rqstp)
{
	static StoreResult result;


	if (loggedMap.find(*argp) == loggedMap.end()) {
		return (StoreResult*)NULL;
	} else {
		int count = 0;
		for (auto & entry : database[*argp]) {
		
			result.clients_data[count].dataId = entry.first;
			result.clients_data[count].noValues = entry.second.size();
			copy(entry.second.begin(), entry.second.end(), result.clients_data[count].values);
			cout << result.clients_data[count].dataId << endl;
			count++;
		}
		result.num = count;
	
	}
 	return &result;
}

Stats *
get_stat_1_svc(IntegerParam *argp, struct svc_req *rqstp)
{
	static Stats  result;

	/*
	 * insert server code here
	 */

	return &result;
}

AllStatsResp *
get_stat_all_1_svc(void *argp, struct svc_req *rqstp)
{
	static AllStatsResp  result;

	/*
	 * insert server code here
	 */

	return &result;
}
