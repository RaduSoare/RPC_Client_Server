/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpc_db.hpp"
#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
using namespace std;

bool is_logged = false;
bool can_load = true;



#define LOGIN_CMD "login"
#define LOGOUT_CMD "logout"
#define LOAD_CMD "load"
#define STORE_CMD "store"
#define ADD_CMD "add"
#define DEL_CMD "del"
#define UPDATE_CMD "update"
#define READ_CMD "read"
#define READ_ALL_CMD "read_all"
#define GET_STAT_CMD "get_stat"
#define GET_STAT_ALL_CMD "get_stat_all"
#define ERROR_CODE -1
#define ERROR_BOOL false



LoadParam load_data_from_disk_new(string filepath, unsigned long session_key) {
	
	string line;
	fstream fs;

	// Open file for read
	fs.open(filepath, std::ios_base::in | std::ios::app);

	int count = 0;
	LoadParam load_arg;

	// Read every line from local database
	while(getline(fs, line)) {

		SensorData current_data;
		std::istringstream iss(line);
		float i;
		iss >> current_data.dataId;
		iss >> current_data.noValues;
		
		int index = 0;
		while (iss >> i) {             
			current_data.values[index++] = i;
		}

		load_arg.clients_data[count] = current_data;
		count++;

	}

	fs.close();

	load_arg.num = count;
	load_arg.session_key = session_key;

	return load_arg;

}

void store_data_to_disk_new(StoreResult* read_all_result, string filepath) {

	

	ofstream ofs (filepath, std::ofstream::in | std::ofstream::trunc);

	for (int i = 0; i < read_all_result->num; i++) {

		ofs << read_all_result->clients_data[i].dataId << " " << read_all_result->clients_data[i].noValues << " ";

		for (int j = 0; j < read_all_result->clients_data[i].noValues; j++) {
			ofs << read_all_result->clients_data[i].values[j] << " ";
		}
		ofs << endl;
	}

	ofs.close();
}



int main (int argc, char *argv[]) 
{
	CLIENT *clnt;
	

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}

#ifndef	DEBUG
	clnt = clnt_create (argv[1], RPC_DB_PROG, RPC_DB_VER, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (argv[1]);
		exit (1);
	}
#endif	/* DEBUG */

	string input_command;
	string filepath;

	LoginCredentials  *login_result;
	


	ifstream infile(argv[2]);

	while (getline(infile, input_command))
	{
		
		std::istringstream iss(input_command);
		cout << input_command << endl;

		string cmd;

		// Extract the command
		iss >> cmd;



		if (cmd == LOGIN_CMD) {

			// Get username from login command
			string username;
			iss >> username;
			fstream fs;
			
			// Check for correct command
			if (username.empty() ) {
				cout << "Invalid username" << endl;
				continue;
			}
			char* login_arg = new char[30];
			strcpy(login_arg, username.c_str());

			// Check if user is already logged
			if (is_logged == true) {
				cout << "Already logged" << endl;
				continue;
			} else {

				login_result = login_1(&login_arg, clnt);

				// If session_key is 0, it means that there was a problem
				if (login_result->session_key == 0) {
					clnt_perror (clnt, "call failed");
					continue;
				} else {
					cout << "Logged in: " << login_result->username << endl;
					// Compute the path to the database on the disk
					filepath = username + ".rpcdb";
					// Create or open user's file
					fs.open(filepath, fstream::in | fstream::out | fstream::app);
					is_logged = true;
				}

			}
		} else if (input_command == LOGOUT_CMD) {
			// Cannot execute this command if you're not logged in
			if (is_logged == false) {
				cout << "You are not logged in" << endl;
				continue;
			}

			bool_t  *logout_result = logout_1(login_result, clnt);
			if (*logout_result == ERROR_BOOL) {
				clnt_perror (clnt, "call failed");
				continue;
			} else {
				cout << "Logged out" << endl;
				is_logged = false;
			}

		} else if (input_command == LOAD_CMD) {

			// Cannot execute this command if you're not logged in
			if (is_logged == false) {
				cout << "You are not logged in" << endl;
				continue;
			}
			
			// Cannot execute this command if the users executed other commands before
			if (can_load == false) {
				cout << "Cannot execute LOAD command" << endl;
				continue;
			}

			// Load data from disk in a LoadParam struct 
			LoadParam load_arg = load_data_from_disk_new(filepath, login_result->session_key);

			bool_t  *load_result = load_1(&load_arg, clnt);
			if (*load_result == ERROR_BOOL) {
				clnt_perror (clnt, "call failed");
				continue;
				
			}
			cout << "Load done" << endl;

		} else if (input_command == STORE_CMD) {

			// Cannot execute this command if you're not logged in
			if (is_logged == false) {
				cout << "You are not logged in" << endl;
				continue;
			}

			// Read user's data from the server using same functionality as READ_ALL
			StoreResult* read_all_result = read_all_1(&(login_result->session_key), clnt);
			// If number of results is 0, it means that there was no user's data onteh server
			if (read_all_result->num == 0) {
				clnt_perror (clnt, "call failed");
				continue;
			}

			// Write retrieved data to local database
			store_data_to_disk_new(read_all_result, filepath);

		} else if (cmd == ADD_CMD) {
			
			if (is_logged == false) {
				cout << "You are not logged in" << endl;
				continue;
			}

			// Compute new data from user input
			SensorDataParam* sensor_data_param = new SensorDataParam;

			sensor_data_param->session_key = login_result->session_key;

			iss >> sensor_data_param->sensor_data.dataId;
			iss >> sensor_data_param->sensor_data.noValues;
			
			for (int i = 0; i < sensor_data_param->sensor_data.noValues; i++) {
				iss >> sensor_data_param->sensor_data.values[i];
			}

			bool_t  *add_result = add_1(sensor_data_param, clnt);
			if (*add_result == ERROR_BOOL) {
				clnt_perror (clnt, "call failed");
				continue;
			}
			can_load = false;
			

		} else if (cmd == UPDATE_CMD) {

			if (is_logged == false) {
				cout << "You are not logged in" << endl;
				continue;
			}

			SensorDataParam* sensor_data_param = new SensorDataParam;
			
			// Compute new data from user input
			sensor_data_param->session_key = login_result->session_key;

			iss >> sensor_data_param->sensor_data.dataId;
			iss >> sensor_data_param->sensor_data.noValues;
			
			for (int i = 0; i < sensor_data_param->sensor_data.noValues; i++) {
				iss >> sensor_data_param->sensor_data.values[i];
			}

			bool_t  *update_result= update_1(sensor_data_param, clnt);
			if (*update_result == ERROR_BOOL) {
				clnt_perror (clnt, "call failed");
				continue;
			}
			can_load = false;

		} else if (cmd == DEL_CMD) { 
			
			IntegerParam*  del_arg = new IntegerParam;
			del_arg->session_key = login_result->session_key;
			iss >> del_arg->value;

			bool_t  *del_result = del_1(del_arg, clnt);
			if (*del_result == ERROR_BOOL) {
				clnt_perror (clnt, "call failed");
				continue;
			} 
			can_load = false;
		} else if (cmd == READ_CMD) {

			if (is_logged == false) {
				cout << "You are not logged in" << endl;
				continue;
			}

			IntegerParam*  read_arg = new IntegerParam;
			read_arg->session_key = login_result->session_key;
			iss >> read_arg->value;

			SensorData  *read_result = read_1(read_arg, clnt);
			if (read_result->dataId == ERROR_CODE) {
				clnt_perror (clnt, "call failed");
				continue;
			}

			cout << read_result->dataId << " " << read_result->noValues << " ";
			for (int i = 0; i < read_result->noValues; i++) {
				cout << read_result->values[i] << " ";
			}
			cout << endl;
			can_load = false;

		} else if (cmd == READ_ALL_CMD) {

			if (is_logged == false) {
				cout << "You are not logged in" << endl;
				continue;
			}
			
			StoreResult* read_all_result = read_all_1(&(login_result->session_key), clnt);
			if (read_all_result->num == 0) {
				clnt_perror (clnt, "call failed");
				continue;
			}
			
			for (int i = 0; i < read_all_result->num; i++) {
				cout << read_all_result->clients_data[i].dataId << " " << read_all_result->clients_data[i].noValues << " ";
				for (int j = 0; j < read_all_result->clients_data[i].noValues; j++) {
					cout << read_all_result->clients_data[i].values[j] << " ";
				}
				cout<< endl;
			}

			can_load = false;

		} else if (cmd == GET_STAT_CMD) {

			if (is_logged == false) {
				cout << "You are not logged in" << endl;
				continue;
			}

			IntegerParam  get_stat_arg;
			get_stat_arg.session_key = login_result->session_key;
			iss >> get_stat_arg.value;


			Stats  *result_10 = get_stat_1(&get_stat_arg, clnt);
			if (result_10->id == ERROR_CODE) {
				clnt_perror (clnt, "call failed");
				continue;
			};
			
			cout << result_10->min << endl;
			cout << result_10->max << endl;
			cout << result_10->mean << endl;
			cout << result_10->median << endl;
		
		} else if (cmd == GET_STAT_ALL_CMD) {
			
			if (is_logged == false) {
				cout << "You are not logged in" << endl;
				continue;
			}

			AllStatsResp  *result_get_stat_all = get_stat_all_1(&login_result->session_key, clnt);
			if (result_get_stat_all->count == 0) {
				clnt_perror (clnt, "call failed");
				continue;
			}
			for (int i = 0; i < result_get_stat_all->count; i++) {
				cout << result_get_stat_all->stats[i].id << " " << result_get_stat_all->stats[i].min << " " << result_get_stat_all->stats[i].max << " " << result_get_stat_all->stats[i].mean << " " << result_get_stat_all->stats[i].median << endl;
			}

			can_load = false;
		}
	}
	



#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


// de facut functie de destroy care elibereaza memoria si la values